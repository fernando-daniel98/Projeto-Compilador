%   %% abtex2-modelo-relatorio-tecnico.tex, v-1.9.6 laurocesar
%% Copyright 2012-2016 by abnTeX2 group at http://www.abntex.net.br/ 
%%
%% This work may be distributed and/or modified under the
%% conditions of the LaTeX Project Public License, either version 1.3
%% of this license or (at your option) any later version.
%% The latest version of this license is in
%%   http://www.latex-project.org/lppl.txt
%% and version 1.3 or later is part of all distributions of LaTeX
%% version 2005/12/01 or later.
%%
%% This work has the LPPL maintenance status `maintained'.
%% 
%% The Current Maintainer of this work is the abnTeX2 team, led
%% by Lauro César Araujo. Further information are available on 
%% http://www.abntex.net.br/
%%
%% This work consists of the files abntex2-modelo-relatorio-tecnico.tex,
%% abntex2-modelo-include-comandos and abntex2-modelo-references.bib
%%

% ------------------------------------------------------------------------
% ------------------------------------------------------------------------
% abnTeX2: Modelo de Relatório Técnico/Acadêmico em conformidade com 
% ABNT NBR 10719:2015 Informação e documentação - Relatório técnico e/ou
% científico - Apresentação
% ------------------------------------------------------------------------ 
% ------------------------------------------------------------------------

\documentclass[
	% -- opções da classe memoir --
	12pt,				% tamanho da fonte
	%openright,			% capítulos começam em pág ímpar (insere página vazia caso preciso)
	%twoside,           % para impressão em recto e verso. Oposto a oneside
	oneside,
	a4paper,			% tamanho do papel. 
	% -- opções da classe abntex2 --
	%chapter=TITLE,		% títulos de capítulos convertidos em letras maiúsculas
	%section=TITLE,		% títulos de seções convertidos em letras maiúsculas
	%subsection=TITLE,	títulos de subseções convertidos em letras maiúsculas
	%subsubsection=TITLE,% títulos de subsubseções convertidos em letras maiúsculas
	% -- opções do pacote babel --
	english,			% idioma adicional para hifenização
	french,				% idioma adicional para hifenização
	spanish,			% idioma adicional para hifenização
	brazil,				% o último idioma é o principal do documento
	]{abntex2}



% PACOTES

% ---
% PACOTES FUNDAMENTAIS
\usepackage{lmodern}			% Usa a fonte Latin Modern
\usepackage[T1]{fontenc}		% Selecao de codigos de fonte.
\usepackage[utf8]{inputenc}		% Codificacao do documento (conversão automática dos acentos)
\usepackage{indentfirst}		% Indenta o primeiro parágrafo de cada seção.
\usepackage{color}				% Controle das cores
\usepackage{graphicx}			% Inclusão de gráficos
\usepackage{microtype} 			% para melhorias de justificação
\usepackage{url}
\usepackage[export]{adjustbox}
\usepackage{multicol}
\usepackage{multirow}
\usepackage{float} % para utilizar o H de tabelas e figuras e mante-las no lugar
% ---
\usepackage[export]{adjustbox}
% Pacotes adicionais, usados no anexo do modelo de folha de identificação
\usepackage{multicol}
\usepackage{multirow}

\usepackage{float} % para utilizar o H de tabelas e figuras e mante-las no lugar
% ---

%----------------- PARA INSERIR ARQUIVOS DE CODIGOS -----------------%
\usepackage{xcolor}
% Definindo novas cores
\definecolor{verde}{rgb}{0,0.5,0}
\definecolor{azul}{rgb}{0,0,0.8}
\definecolor{cinza}{rgb}{0.5,0.5,0.5}
% Configurando layout para mostrar codigos C++
\usepackage{listings}

\lstset{
  language=Verilog, %indicar a linguagem utilizada
  basicstyle=\ttfamily\tiny, 
  keywordstyle=\color{blue}, 
  stringstyle=\color{verde}, 
  commentstyle=\color{gray}, 
  extendedchars=true, 
  showspaces=false, 
  showstringspaces=false, 
  numbers=left,
  numberstyle=\tiny,
  breaklines=true, 
  backgroundcolor=\color{green!10},
  breakautoindent=true, 
  captionpos=b,
  xleftmargin=0pt,
}

\lstdefinestyle{cstyle}{
    language=C,
    basicstyle=\ttfamily\footnotesize,
    keywordstyle=\color{blue}\bfseries,
    stringstyle=\color{verde},
    commentstyle=\color{cinza}\itshape,
    numberstyle=\tiny\color{cinza},
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    breaklines=true,
    captionpos=b,
    frame=single,
    rulecolor=\color{black},
    backgroundcolor=\color{gray!10},
    xleftmargin=17pt,
    framexleftmargin=17pt,
    framexrightmargin=5pt,
    framexbottommargin=4pt,
}
% -----------------% FIM INSERIR ARQUIVOs DE CODIGO -----------------%

% Pacotes de citações
\usepackage[brazilian,hyperpageref]{backref}	 % Paginas com as citações na bibl
\usepackage[alf]{abntex2cite}	% Citações padrão ABNT
\citebrackets() %citação numérica entre colchetes
% --- 


% CONFIGURAÇÕES DE PACOTES

% Configurações do pacote backref
% Usado sem a opção hyperpageref de backref
\renewcommand{\backrefpagesname}{Citado na(s) página(s):~}
% Texto padrão antes do número das páginas
\renewcommand{\backref}{}
% Define os textos da citação
\renewcommand*{\backrefalt}[4]{
	\ifcase #1 %
		Nenhuma citação no texto.%
	\or
		Citado na página #2.%
	\else
		Citado #1 vezes nas páginas #2.%
	\fi}%
% ---
% Informações de dados para CAPA e FOLHA DE ROSTO
\titulo{Implementação do Compilador C-}
\autor{Fernando Daniel Marcelino\\156490}
\local{São José dos Campos - Brasil}
\data{Junho de 2025}
\instituicao{
  Docente: Prof. Dr. [Nome do Professor]
  \par
  Universidade Federal de São Paulo - UNIFESP
  \par
  Instituto de Ciência e Tecnologia - Campus São José dos Campos
}
\tipotrabalho{Relatório técnico}
\preambulo{Relatório apresentado à Universidade Federal de São Paulo como parte dos requisitos para aprovação na disciplina de Laboratório de Sistemas Computacionais: Compiladores.}
% ---

% Configurações de aparência do PDF final

% alterando o aspecto da cor azul
\definecolor{blue}{RGB}{41,5,195}

% informações do PDF
\makeatletter
\hypersetup{
     	%pagebackref=true,
		pdftitle={\@title}, 
		pdfauthor={\@author},
    	pdfsubject={\imprimirpreambulo},
	    pdfcreator={LaTeX with abnTeX2},
		pdfkeywords={abnt}{latex}{abntex}{abntex2}{relatório técnico}, 
		colorlinks=true,       		% false: boxed links; true: colored links
    	linkcolor=blue,          	% color of internal links
    	citecolor=blue,        		% color of links to bibliography
    	filecolor=magenta,      		% color of file links
		urlcolor=blue,
		bookmarksdepth=4
}
\makeatother
% --- 


% Espaçamentos entre linhas e parágrafos 

% O tamanho do parágrafo é dado por:
\setlength{\parindent}{1.3cm}

% Controle do espaçamento entre um parágrafo e outro:
\setlength{\parskip}{0.2cm}  % tente também \onelineskip

% compila o indice
\makeindex
% ---



% ------------------------------------------------
% Início do documento
\begin{document}

% Seleciona o idioma do documento (conforme pacotes do babel)
%\selectlanguage{english}
\selectlanguage{brazil}

% Retira espaço extra obsoleto entre as frases.
\frenchspacing 

% ----------------------------------------------------------
% ELEMENTOS PRÉ-TEXTUAIS
% ----------------------------------------------------------
% \pretextual

% Capa
\imprimircapa

% Folha de rosto
\imprimirfolhaderosto*

% RESUMO
\setlength{\absparsep}{18pt}
\begin{resumo}

Este relatório apresenta o desenvolvimento completo de um compilador para a linguagem C-, uma versão simplificada da linguagem C, direcionado ao processador MIPS-64. O projeto implementa todas as fases da compilação, desde a análise léxica até a geração de código binário executável. A fase de análise compreende análise léxica implementada em Flex, análise sintática em Bison com construção de árvore sintática abstrata, e análise semântica com verificação de tipos e escopo. A fase de síntese inclui geração de código intermediário através de quádruplas, tradução para assembly MIPS-64 e geração de código binário. O compilador suporta completamente a linguagem C-, incluindo declarações de variáveis e arrays, estruturas de controle, funções com recursão, operações aritméticas e lógicas, e funções de entrada e saída. Os testes realizados demonstram a corretude funcional do compilador através de exemplos práticos que mostram a correspondência entre código fonte, código intermediário, assembly e código executável. O sistema gera código compatível com a arquitetura MIPS-64, demonstrando sua eficiência através de programas que incluem operações aritméticas, algoritmos recursivos e manipulação de arrays interativa.

\noindent
\textbf{Palavras-chave}: Compilador. Linguagem C-. MIPS-64. Análise léxica. Análise sintática. Geração de código assembly.
\end{resumo}

% inserir lista de ilustrações
\pdfbookmark[0]{\listfigurename}{lof}
\listoffigures*
\clearpage

% inserir lista de tabelas
\pdfbookmark[0]{\listtablename}{lot}
\listoftables*
\clearpage

% inserir o sumario
\pdfbookmark[0]{\contentsname}{toc}
\tableofcontents*

% ----------------------------------------------------------
% ELEMENTOS TEXTUAIS
\textual

% ----------------- Introdução -------------------------------
\chapter{Introdução}

Os compiladores constituem uma das ferramentas fundamentais da ciência da computação moderna, responsáveis pela tradução de linguagens de programação de alto nível para código executável. A construção de um compilador envolve profundo conhecimento em teoria de linguagens formais, algoritmos de parsing, análise semântica e geração de código, representando um dos projetos mais completos e desafiadores no estudo de sistemas computacionais \cite{Aho2007}.

O desenvolvimento de compiladores está intrinsecamente ligado à arquitetura dos processadores para os quais o código é gerado. A compreensão da organização interna do processador, seu conjunto de instruções, modos de endereçamento e convenções de chamada de função são essenciais para a geração de código eficiente e correto. Neste projeto, o compilador foi desenvolvido especificamente para o processador MIPS-64, aproveitando as características desta arquitetura RISC para produzir código assembly otimizado.

A linguagem C- representa uma versão simplificada da linguagem C, mantendo suas características essenciais como declarações de variáveis, estruturas de controle (if-else, while), funções com parâmetros e operações aritméticas, mas removendo complexidades como ponteiros e estruturas. Esta simplificação torna a linguagem ideal para o aprendizado dos conceitos fundamentais de compilação, permitindo focar nos aspectos mais importantes do processo de tradução.

O processador MIPS-64, extensão de 64 bits da arquitetura MIPS tradicional, oferece um conjunto de instruções bem estruturado e documentado, tornando-se uma escolha natural para projetos educacionais. Sua arquitetura RISC (Reduced Instruction Set Computer) simplifica o processo de geração de código, enquanto mantém todas as funcionalidades necessárias para executar programas complexos.

Este projeto representa a implementação completa de um compilador para a linguagem C-, abrangendo todas as fases da compilação: análise léxica, análise sintática, análise semântica, geração de código intermediário, geração de código assembly e geração de código binário executável. O compilador foi desenvolvido com foco na correção funcional e na geração de código eficiente para o processador MIPS-64.

\section{Organização do Relatório}

Este relatório está organizado nos seguintes capítulos:

\begin{itemize}
    \item \textbf{Capítulo 2 - O Processador}: Apresenta a arquitetura do processador MIPS-64 alvo, incluindo seu conjunto de instruções, organização da memória e características relevantes para a geração de código.
    
    \item \textbf{Capítulo 3 - Compilador: Fase de Análise}: Detalha a implementação das fases de análise do compilador, incluindo análise léxica, sintática e semântica, com modelagem através de diagramas e descrição dos algoritmos utilizados.
    
    \item \textbf{Capítulo 4 - Compilador: Fase de Síntese}: Descreve a implementação das fases de síntese, abrangendo geração de código intermediário, assembly e binário, além do gerenciamento de memória.
    
    \item \textbf{Capítulo 5 - Exemplos}: Apresenta exemplos práticos da utilização do compilador, mostrando a evolução do código fonte através de todas as fases até o código executável final.
    
    \item \textbf{Capítulo 6 - Conclusão}: Reflexões sobre o projeto, dificuldades encontradas e destaques da implementação.
\end{itemize}

% ---------------- O Processador -------------------------------------
\chapter{O Processador}

O processador MIPS-64 utilizado neste projeto representa uma extensão da arquitetura MIPS clássica, trabalhando com palavras de 64 bits. Esta seção descreve a arquitetura do processador, seus componentes principais e o conjunto de instruções suportado.

\section{Diagrama de Blocos do Processador}

A arquitetura geral do processador MIPS-64 segue o modelo Harvard, com memórias separadas para instruções e dados. A \autoref{fig:diagrama-processador} apresenta a organização dos componentes principais:

\begin{figure}[H]
\centering
\caption{Diagrama de blocos do processador MIPS-64}
\label{fig:diagrama-processador}
\begin{minipage}{0.9\textwidth}
\textbf{Componentes Principais do Processador:}
\begin{itemize}
    \item \textbf{Unidade de Controle} $\rightarrow$ Coordena a execução das instruções
    \item \textbf{ULA (64 bits)} $\rightarrow$ Realiza operações aritméticas e lógicas
    \item \textbf{Banco de Registradores} $\rightarrow$ 32 registradores de 64 bits (numerados 0-31)
    \item \textbf{Memória de Instruções} $\rightarrow$ Armazena o programa (Harvard, ROM)
    \item \textbf{Memória de Dados} $\rightarrow$ Armazena variáveis e dados (RAM)
    \item \textbf{Program Counter (PC)} $\rightarrow$ Controla sequência de execução
    \item \textbf{Multiplexadores} $\rightarrow$ Seleção de fontes de dados
    \item \textbf{Extensor de Sinal} $\rightarrow$ Extensão de imediatos de 16 para 64 bits
\end{itemize}

\textbf{Barramentos:}
\begin{itemize}
    \item \textbf{Barramento de Instruções} $\rightarrow$ 32 bits (Memória de Instruções → UC)
    \item \textbf{Barramento de Dados} $\rightarrow$ 64 bits (Registradores ↔ ULA ↔ Memória)
    \item \textbf{Barramento de Endereços} $\rightarrow$ 32 bits (PC → Memória de Instruções)
    \item \textbf{Barramento de Controle} $\rightarrow$ Sinais de controle da UC
\end{itemize}
\end{minipage}
\\
\textit{Fonte: O Autor}
\end{figure}

\textbf{Fluxo de Execução:}
\begin{enumerate}
    \item PC aponta para endereço da instrução na Memória de Instruções
    \item Instrução é decodificada pela Unidade de Controle  
    \item Operandos são lidos do Banco de Registradores
    \item ULA executa a operação especificada
    \item Resultado é escrito de volta no registrador destino
    \item PC é atualizado para próxima instrução
\end{enumerate}

\section{Componentes do Processador}

O processador é composto pelos seguintes componentes principais:

\subsection{Unidade de Controle}
Responsável pela decodificação das instruções e geração dos sinais de controle necessários para coordenar o funcionamento de todos os componentes do processador. A unidade de controle interpreta o opcode das instruções e ativa os sinais apropriados para cada tipo de operação.

\subsection{Unidade Lógica e Aritmética (ULA)}
Executa todas as operações aritméticas e lógicas do processador, incluindo adição, subtração, multiplicação, divisão, operações AND, OR, e comparações. A ULA produz também sinais de status, como zero e overflow.

\subsection{Banco de Registradores}
O processador possui 32 registradores de 64 bits cada, numerados de 0 a 31. A convenção utilizada neste projeto define funções especiais para alguns registradores:
\begin{itemize}
    \item \textbf{\$zero (\$31)}: Sempre contém o valor zero
    \item \textbf{\$ra (\$30)}: Registrador de endereço de retorno
    \item \textbf{\$fp (\$29)}: Ponteiro de frame
    \item \textbf{\$sp (\$28)}: Ponteiro de pilha  
    \item \textbf{\$temp (\$27)}: Registrador temporário especial
    \item \textbf{\$t0-\$t22 (\$0-\$22)}: Registradores temporários
    \item \textbf{\$s0-\$s2 (\$23-\$25)}: Registradores salvos
\end{itemize}

\subsection{Memória de Instruções (ROM)}
Armazena o programa a ser executado. Cada posição contém uma instrução de 32 bits. O acesso é realizado através do Program Counter (PC).

\subsection{Memória de Dados (RAM)}
Armazena dados do programa, incluindo variáveis e arrays. Suporta operações de leitura e escrita através das instruções load e store.

\subsection{Program Counter (PC)}
Registrador especial que contém o endereço da próxima instrução a ser executada. É incrementado automaticamente ou modificado por instruções de salto.

\section{Conjunto de Instruções do Processador}

O processador implementa um subconjunto das instruções MIPS, organizadas em três formatos básicos:

\subsection{Formato das Instruções}

\begin{table}[H]
\centering
\caption{Formatos de instrução do processador MIPS-64}
\begin{tabular}{|c|c|c|c|c|c|}
\hline
\textbf{Tipo} & \textbf{Bits 31-26} & \textbf{Bits 25-21} & \textbf{Bits 20-16} & \textbf{Bits 15-11} & \textbf{Bits 10-0} \\
\hline
R & opcode (6) & rs (5) & rt (5) & rd (5) & shamt (5) + funct (6) \\
\hline
I & opcode (6) & rs (5) & rt (5) & \multicolumn{2}{c|}{imediato (16)} \\
\hline
J & opcode (6) & \multicolumn{4}{c|}{endereço (26)} \\
\hline
\end{tabular}
\end{table}

\subsection{Instruções Tipo R}

\begin{table}[H]
\centering
\caption{Instruções do tipo R implementadas}
\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Instrução} & \textbf{Opcode} & \textbf{Funct} & \textbf{Operação} \\
\hline
add & 000000 & 100000 & rd = rs + rt \\
\hline
sub & 000000 & 100010 & rd = rs - rt \\
\hline
mult & 000000 & 011000 & rd = rs * rt \\
\hline
div & 000000 & 011010 & rd = rs / rt \\
\hline
and & 000000 & 100100 & rd = rs AND rt \\
\hline
or & 000000 & 100101 & rd = rs OR rt \\
\hline
slt & 000000 & 101010 & rd = (rs < rt) ? 1 : 0 \\
\hline
sll & 000000 & 000000 & rd = rt << shamt \\
\hline
srl & 000000 & 000010 & rd = rt >> shamt \\
\hline
jr & 000000 & 001000 & PC = rs \\
\hline
\end{tabular}
\end{table}

\subsection{Instruções Tipo I}

\begin{table}[H]
\centering
\caption{Instruções do tipo I implementadas}
\begin{tabular}{|l|l|l|}
\hline
\textbf{Instrução} & \textbf{Opcode} & \textbf{Operação} \\
\hline
lw & 100011 & rt = Mem[rs + imediato] \\
\hline
sw & 101011 & Mem[rs + imediato] = rt \\
\hline
ori & 001101 & rt = rs OR imediato \\
\hline
addi & 001000 & rt = rs + imediato \\
\hline
subi & 001001 & rt = rs - imediato \\
\hline
beq & 000100 & if (rs == rt) PC = PC + 4 + (imediato << 2) \\
\hline
bne & 000101 & if (rs != rt) PC = PC + 4 + (imediato << 2) \\
\hline
in & 011111 & rt = input() \\
\hline
out & 011110 & output(rs) \\
\hline
\end{tabular}
\end{table}

\subsection{Instruções Tipo J}

\begin{table}[H]
\centering
\caption{Instruções do tipo J implementadas}
\begin{tabular}{|l|l|l|}
\hline
\textbf{Instrução} & \textbf{Opcode} & \textbf{Operação} \\
\hline
j & 000010 & PC = endereço \\
\hline
jal & 000011 & \$ra = PC + 4; PC = endereço \\
\hline
halt & 111111 & Parar execução \\
\hline
\end{tabular}
\end{table}

\section{Organização da Memória}

A organização da memória segue o modelo Harvard com as seguintes características:

\subsection{Memória de Instruções}
\begin{itemize}
    \item Tamanho: 1024 posições de 32 bits cada
    \item Endereçamento: 0x00000000 a 0x000003FF
    \item Acesso: Somente leitura
    \item Carregamento: Através de arquivo de inicialização
\end{itemize}

\subsection{Memória de Dados}
\begin{itemize}
    \item Tamanho: 1024 posições de 64 bits cada
    \item Endereçamento: 0x00000000 a 0x000003FF
    \item Acesso: Leitura e escrita
    \item Organização: Suporte a variáveis e arrays
\end{itemize}

\subsection{Mapeamento de Memória}
A memória de dados é organizada da seguinte forma:

\begin{table}[H]
\centering
\caption{Mapeamento da memória de dados}
\begin{tabular}{|l|l|l|}
\hline
\textbf{Região} & \textbf{Endereços} & \textbf{Uso} \\
\hline
Variáveis Globais & 0x000 - 0x0FF & Variáveis globais do programa \\
\hline
Pilha & 0x100 - 0x2FF & Pilha de execução (cresce para baixo) \\
\hline
Heap & 0x300 - 0x3FF & Espaço para arrays e dados dinâmicos \\
\hline
\end{tabular}
\end{table}

\section{Convenções de Uso dos Registradores}

\begin{table}[H]
\centering
\caption{Convenções de uso dos registradores}
\begin{tabular}{|l|l|l|}
\hline
\textbf{Registrador} & \textbf{Nome} & \textbf{Uso} \\
\hline
\$31 & \$zero & Constante zero \\
\hline
\$0-\$22 & \$t0-\$t22 & Registradores temporários \\
\hline
\$23-\$25 & \$s0-\$s2 & Registradores salvos \\
\hline
\$26 & \$pilha & Ponteiro para pilha de parâmetros \\
\hline
\$27 & \$temp & Registrador temporário especial \\
\hline
\$28 & \$sp & Ponteiro de pilha \\
\hline
\$29 & \$fp & Ponteiro de frame \\
\hline
\$30 & \$ra & Endereço de retorno \\
\hline
\end{tabular}
\end{table}

% --------------- Fundamentação Teórica ---------------
\chapter{Fundamentação Teórica}

\section{Teoria de Compiladores}

\subsection{Fases da Compilação}
Um compilador moderno é organizado em várias fases distintas, cada uma responsável por uma etapa específica da tradução do código fonte \cite{Aho2007}. As principais fases são:

\begin{enumerate}
    \item \textbf{Análise Léxica}: Converte a sequência de caracteres do código fonte em uma sequência de tokens, que são as unidades básicas da linguagem como palavras-chave, identificadores, números e operadores.
    
    \item \textbf{Análise Sintática}: Verifica se a sequência de tokens está em conformidade com a gramática da linguagem, construindo uma árvore sintática que representa a estrutura hierárquica do programa.
    
    \item \textbf{Análise Semântica}: Realiza verificações de tipo, escopo de variáveis, declarações e outras regras semânticas da linguagem, garantindo que o programa seja semanticamente correto.
    
    \item \textbf{Geração de Código Intermediário}: Produz uma representação intermediária do programa, independente da arquitetura alvo, facilitando a otimização e geração final de código.
    
    \item \textbf{Otimização de Código}: Aplica transformações ao código intermediário para melhorar sua eficiência, reduzindo tempo de execução e uso de memória.
    
    \item \textbf{Geração de Código}: Traduz o código intermediário para código de máquina ou assembly da arquitetura alvo.
\end{enumerate}

\subsection{Análise Léxica e Autômatos Finitos}
A análise léxica é baseada na teoria de autômatos finitos e expressões regulares. Cada token da linguagem pode ser definido por uma expressão regular, e o conjunto de todas as expressões regulares pode ser convertido em um autômato finito determinístico (AFD) que reconhece os tokens \cite{Sipser2012}.

A ferramenta Flex (Fast Lexical Analyzer Generator) automatiza este processo, permitindo especificar tokens através de expressões regulares e gerando automaticamente o código C correspondente ao analisador léxico.

\subsection{Análise Sintática e Gramáticas Livres de Contexto}
A análise sintática é fundamentada na teoria de gramáticas livres de contexto. Uma gramática livre de contexto G é uma 4-tupla (V, T, P, S) onde:
\begin{itemize}
    \item V é um conjunto finito de símbolos não-terminais
    \item T é um conjunto finito de símbolos terminais
    \item P é um conjunto finito de produções
    \item S é o símbolo inicial
\end{itemize}

O analisador sintático verifica se uma sequência de tokens pertence à linguagem gerada pela gramática, construindo simultaneamente uma árvore de derivação ou árvore sintática abstrata.

\subsection{Técnicas de Parsing}
Existem duas principais abordagens para análise sintática:

\textbf{Parsing Top-Down}: Constrói a árvore sintática a partir da raiz, utilizando técnicas como parsing recursivo descendente ou parsing LL(k).

\textbf{Parsing Bottom-Up}: Constrói a árvore sintática a partir das folhas, utilizando técnicas como parsing LR(k), SLR ou LALR.

A ferramenta Bison (GNU Yacc) implementa parsing LALR(1), uma variante eficiente do parsing LR que é adequada para a maioria das linguagens de programação.

\section{Arquitetura MIPS}

\subsection{Características Gerais}
A arquitetura MIPS (Microprocessor without Interlocked Pipeline Stages) é uma arquitetura RISC desenvolvida nos anos 1980 \cite{Patterson2013}. Suas principais características incluem:

\begin{itemize}
    \item Conjunto de instruções reduzido e regular
    \item Formato de instruções uniformes (32 bits na versão original)
    \item Grande número de registradores de propósito geral
    \item Arquitetura load/store (operações aritméticas apenas entre registradores)
    \item Pipeline simples e eficiente
\end{itemize}

\subsection{MIPS-64}
A arquitetura MIPS-64 estende o MIPS original para 64 bits, oferecendo:
\begin{itemize}
    \item Registradores de 64 bits
    \item Espaço de endereçamento de 64 bits
    \item Instruções para manipulação de dados de 64 bits
    \item Compatibilidade com código MIPS-32
\end{itemize}

\subsection{Formato de Instruções}
As instruções MIPS seguem três formatos básicos:

\textbf{Tipo R (Registrador)}:
\begin{table}[H]
\centering
\caption{Formato de Instrução Tipo R}
\begin{tabular}{|c|c|c|c|c|c|}
\hline
opcode & rs & rt & rd & shamt & funct \\
\hline
6 bits & 5 bits & 5 bits & 5 bits & 5 bits & 6 bits \\
\hline
\end{tabular}
\end{table}

\textbf{Tipo I (Imediato)}:
\begin{table}[H]
\centering
\caption{Formato de Instrução Tipo I}
\begin{tabular}{|c|c|c|c|}
\hline
opcode & rs & rt & imediato \\
\hline
6 bits & 5 bits & 5 bits & 16 bits \\
\hline
\end{tabular}
\end{table}

\textbf{Tipo J (Jump)}:
\begin{table}[H]
\centering
\caption{Formato de Instrução Tipo J}
\begin{tabular}{|c|c|}
\hline
opcode & endereço \\
\hline
6 bits & 26 bits \\
\hline
\end{tabular}
\end{table}

\section{Linguagem C-}

\subsection{Especificação da Linguagem}
A linguagem C- é um subconjunto da linguagem C, projetada para fins educacionais. Suas principais características incluem:

\begin{itemize}
    \item Tipos de dados: int e arrays de int
    \item Estruturas de controle: if-else e while
    \item Funções com parâmetros e valores de retorno
    \item Operações aritméticas: +, -, *, /
    \item Operações relacionais: <, <=, >, >=, ==, !=
    \item Funções de entrada e saída: input() e output()
    \item Comentários: /* ... */
\end{itemize}

\subsection{Gramática da Linguagem C-}
A gramática da linguagem C- em notação BNF é definida como:

\begin{lstlisting}[style=cstyle, caption=Gramática BNF da Linguagem C-]
programa -> declaracao-lista
declaracao-lista -> declaracao-lista declaracao | declaracao
declaracao -> var-declaracao | fun-declaracao
var-declaracao -> tipo-especificador ID ; | 
                  tipo-especificador ID [ NUM ] ;
tipo-especificador -> int | void
fun-declaracao -> tipo-especificador ID ( params ) compound-stmt
params -> param-lista | void
param-lista -> param-lista , param | param
param -> tipo-especificador ID | tipo-especificador ID [ ]
compound-stmt -> { local-declaracoes statement-lista }
local-declaracoes -> local-declaracoes var-declaracao | empty
statement-lista -> statement-lista statement | empty
statement -> expression-stmt | compound-stmt | 
             selection-stmt | iteration-stmt | return-stmt
expression-stmt -> expression ; | ;
selection-stmt -> if ( expression ) statement | 
                  if ( expression ) statement else statement
iteration-stmt -> while ( expression ) statement
return-stmt -> return ; | return expression ;
expression -> var = expression | simple-expression
var -> ID | ID [ expression ]
simple-expression -> additive-expression relop additive-expression |
                     additive-expression
relop -> <= | < | > | >= | == | !=
additive-expression -> additive-expression addop term | term
addop -> + | -
term -> term mulop factor | factor
mulop -> * | /
factor -> ( expression ) | var | call | NUM
call -> ID ( args )
args -> arg-lista | empty
arg-lista -> arg-lista , expression | expression
\end{lstlisting}

% --------------- Compilador: Fase de Análise ---------------
\chapter{Compilador: Fase de Análise}

A fase de análise do compilador é responsável por processar o código fonte e construir uma representação interna que capture tanto a estrutura sintática quanto a semântica do programa. Esta fase é composta por três componentes principais: análise léxica, análise sintática e análise semântica.

\section{Modelagem da Fase de Análise}

\subsection{Diagrama de Blocos}

A fase de análise do compilador segue uma estrutura sequencial onde cada componente processa a saída do anterior:

\begin{figure}[H]
\centering
\caption{Diagrama de blocos da fase de análise}
\label{fig:diagrama-analise}
\begin{minipage}{0.8\textwidth}
\textbf{Fluxo da Fase de Análise:}
\begin{enumerate}
    \item \textbf{Analisador Léxico} $\rightarrow$ Código fonte em caracteres para sequência de tokens
    \item \textbf{Analisador Sintático} $\rightarrow$ Tokens para Árvore Sintática Abstrata (AST)
    \item \textbf{Analisador Semântico} $\rightarrow$ AST para AST anotada com informações de tipos
    \item \textbf{Tabela de Símbolos} $\rightarrow$ Armazena e gerencia informações de identificadores
\end{enumerate}
\end{minipage}
\\
\textit{Fonte: O Autor}
\end{figure}

\subsection{Diagrama de Atividades}

\subsection{Diagrama de Atividades}

O processo de análise segue o fluxo apresentado na \autoref{fig:atividade-analise}:

\begin{figure}[H]
\centering
\caption{Diagrama de atividades da fase de análise}
\label{fig:atividade-analise}
\begin{minipage}{0.7\textwidth}
\textbf{Sequência de Atividades na Análise:}
\begin{enumerate}
    \item \textbf{Início} $\rightarrow$ Receber arquivo fonte
    \item \textbf{Análise Léxica} $\rightarrow$ Tokenização do código
    \item \textbf{Análise Sintática} $\rightarrow$ Construção da AST
    \item \textbf{Verificação de Escopo} $\rightarrow$ Validação de declarações
    \item \textbf{Análise Semântica} $\rightarrow$ Verificação de tipos
    \item \textbf{AST Anotada} $\rightarrow$ Estrutura pronta para síntese
    \item \textbf{Fim}
\end{enumerate}
\end{minipage}
\\
\textit{Fonte: O Autor}
\end{figure}

\section{Análise Léxica}

A análise léxica é a primeira fase do compilador, responsável por converter a sequência de caracteres do código fonte em uma sequência de tokens significativos. Foi implementada utilizando a ferramenta Flex (Fast Lexical Analyzer Generator).

\subsection{Tokens da Linguagem C-}

A linguagem C- possui os seguintes tipos de tokens:

\begin{table}[H]
\centering
\caption{Tokens reconhecidos pelo analisador léxico}
\begin{tabular}{|l|l|l|}
\hline
\textbf{Categoria} & \textbf{Tokens} & \textbf{Exemplo} \\
\hline
Palavras-chave & if, else, while, int, void, return & if, while \\
\hline
Identificadores & [a-zA-Z][a-zA-Z0-9]* & variavel, funcao1 \\
\hline
Números & [0-9]+ & 123, 0, 456 \\
\hline
Operadores Aritméticos & +, -, *, / & +, - \\
\hline
Operadores Relacionais & <, <=, >, >=, ==, != & ==, < \\  
\hline
Operadores de Atribuição & = & = \\
\hline
Delimitadores & (, ), [, ], \{, \}, ;, , & (, ; \\
\hline
Funções E/S & input, output & input() \\
\hline
\end{tabular}
\end{table}

\subsection{Implementação em Flex}

O analisador léxico foi implementado usando expressões regulares em Flex:

\begin{lstlisting}[style=cstyle, caption=Especificação léxica em Flex]
%{
#include "parser.tab.h"
#include "globals.h"
int lineno = 1;
%}

delim       [ \t]
whitespace  {delim}+
newline     \n
letter      [a-zA-Z]
digit       [0-9]
number      {digit}+
identifier  {letter}({letter}|{digit})*
comment     \/\*([^*]|\*+[^*/])*\*+\/

%%
"if"        { return IF; }
"else"      { return ELSE; }
"while"     { return WHILE; }
"return"    { return RETURN; }
"int"       { return INT; }
"void"      { return VOID; }
"input"     { return INPUT; }
"output"    { return OUTPUT; }

"=="        { return EQ; }
"!="        { return NE; }
"<="        { return LE; }
">="        { return GE; }
"<"         { return LT; }
">"         { return GT; }

"+"         { return PLUS; }
"-"         { return MINUS; }
"*"         { return TIMES; }
"/"         { return OVER; }
"="         { return ASSIGN; }

";"         { return SEMI; }
","         { return COMMA; }
"("         { return LPAREN; }
")"         { return RPAREN; }
"["         { return LBRACKET; }
"]"         { return RBRACKET; }
"{"         { return LBRACE; }
"}"         { return RBRACE; }

{number}    { 
    yylval.ival = atoi(yytext);
    return NUM; 
}

{identifier} { 
    yylval.sval = strdup(yytext);
    return ID; 
}

{newline}   { lineno++; }
{whitespace} { /* ignore */ }
{comment}   { /* ignore comments */ }

.           { return ERROR; }
%%
\end{lstlisting}

\section{Análise Sintática}

A análise sintática verifica se a sequência de tokens está em conformidade com a gramática da linguagem C- e constrói uma árvore sintática abstrata (AST) que representa a estrutura do programa.

\subsection{Gramática da Linguagem C-}

A gramática da linguagem C- foi implementada utilizando Bison (GNU Yacc) com as seguintes produções principais:

\begin{lstlisting}[style=cstyle, caption=Gramática BNF da linguagem C-]
programa -> declaracao-lista

call -> ID ( args )

declaracao-lista -> declaracao-lista declaracao
                 | declaracao

declaracao -> var-declaracao
           | fun-declaracao

var-declaracao -> tipo-especificador ID ;
               | tipo-especificador ID [ NUM ] ;

fun-declaracao -> tipo-especificador ID ( params ) compound-stmt

compound-stmt -> { local-declaracoes statement-lista }

statement -> expression-stmt
          | compound-stmt  
          | selection-stmt
          | iteration-stmt
          | return-stmt

selection-stmt -> if ( expression ) statement
               | if ( expression ) statement else statement

iteration-stmt -> while ( expression ) statement

expression -> var = expression
           | simple-expression

var -> ID | ID [ expression ]
simple-expression -> additive-expression relop additive-expression
                  | additive-expression

additive-expression -> additive-expression addop term
                    | term

term -> term mulop factor
     | factor

factor -> ( expression )
       | var
       | call
       | NUM

call -> ID ( args )
\end{lstlisting}

\section{Análise Semântica}

A análise semântica verifica a corretude semântica do programa, incluindo verificação de tipos, escopo de variáveis e consistência de declarações e usos.

\subsection{Tabela de Símbolos}

Foi implementada uma tabela de símbolos com hash para armazenar informações sobre identificadores:

\begin{lstlisting}[style=cstyle, caption=Implementação da tabela de símbolos]
#define SIZE 211

typedef struct SymbolRec {
    char *nome;
    TreeNode *treeNode;
    int location;
    int escopo;
    struct SymbolRec *next;
} SymbolRec;

static SymbolRec *hashTable[SIZE];

// Função hash
static int hash(char *key) {
    int temp = 0;
    int i = 0;
    while (key[i] != '\0') {
        temp = ((temp << SHIFT) + key[i]) % SIZE;
        ++i;
    }
    return temp;
}

// Inserir símbolo
void st_insert(char *name, int lineno, int loc, TreeNode *treeNode) {
    int h = hash(name);
    SymbolRec *l = hashTable[h];
    
    while ((l != NULL) && (strcmp(name, l->nome) != 0))
        l = l->next;
        
    if (l == NULL) {
        l = (SymbolRec *)malloc(sizeof(SymbolRec));
        l->nome = strdup(name);
        l->treeNode = treeNode;
        l->location = loc;
        l->escopo = currentScope;
        l->next = hashTable[h];
        hashTable[h] = l;
    } else {
        reportSemanticError("Símbolo já declarado", lineno);
    }
}
\end{lstlisting}

% --------------- Compilador: Fase de Síntese ---------------
\chapter{Compilador: Fase de Síntese}

A fase de síntese do compilador é responsável por gerar código executável a partir da representação interna criada na fase de análise. Esta fase compreende a geração de código intermediário, código assembly e código binário executável.

\section{Modelagem da Fase de Síntese}

\subsection{Diagrama de Blocos}

A \autoref{fig:diagrama-sintese} apresenta o diagrama de blocos da fase de síntese, mostrando a transformação da AST anotada até o código executável final.

\begin{figure}[H]
\centering
\caption{Diagrama de blocos da fase de síntese}
\label{fig:diagrama-sintese}
\begin{minipage}{0.8\textwidth}
\textbf{Componentes da Fase de Síntese:}
\begin{itemize}
    \item \textbf{Geração de Código Intermediário} $\rightarrow$ Produz código de três endereços
    \item \textbf{Otimização} $\rightarrow$ Melhora eficiência do código
    \item \textbf{Geração de Assembly} $\rightarrow$ Converte para MIPS assembly
    \item \textbf{Geração de Código Binário} $\rightarrow$ Produz código executável
\end{itemize}
\end{minipage}
\\
\textit{Fonte: O Autor}
\end{figure}

\subsection{Diagrama de Atividades}

O processo de síntese segue o fluxo apresentado na \autoref{fig:atividade-sintese}, transformando sucessivamente a representação do programa.

\begin{figure}[H]
\centering
\caption{Diagrama de atividades da fase de síntese}
\label{fig:atividade-sintese}
\begin{minipage}{0.7\textwidth}
\textbf{Fluxo de Atividades na Síntese:}
\begin{enumerate}
    \item \textbf{Início} $\rightarrow$ Árvore Sintática
    \item \textbf{Análise Semântica} $\rightarrow$ Verificação de tipos
    \item \textbf{Geração de Código Intermediário} $\rightarrow$ Quádruplas
    \item \textbf{Otimização} $\rightarrow$ Melhorias no código
    \item \textbf{Geração de Assembly} $\rightarrow$ Código MIPS
    \item \textbf{Geração Binária} $\rightarrow$ Código Executável
    \item \textbf{Fim}
\end{enumerate}
\end{minipage}
\\
\textit{Fonte: O Autor}
\end{figure}

\section{Geração do Código Intermediário}

A geração de código intermediário produz uma representação em código de três endereços (quádruplas) que facilita a posterior geração de código assembly. Esta representação é independente da arquitetura alvo e permite otimizações.

\subsection{Tipos de Quádruplas Definidos}

Foram definidos os seguintes tipos de quádruplas para representar as operações da linguagem C-:

\begin{table}[H]
\centering
\caption{Tipos de quádruplas implementadas}
\begin{tabular}{|l|l|l|}
\hline
\textbf{Tipo} & \textbf{Formato} & \textbf{Descrição} \\
\hline
ASSIGN & (=, arg1, -, result) & Atribuição simples \\
\hline
ADD & (+, arg1, arg2, result) & Adição aritmética \\
\hline
SUB & (-, arg1, arg2, result) & Subtração aritmética \\
\hline
MULT & (*, arg1, arg2, result) & Multiplicação \\
\hline
DIV & (/, arg1, arg2, result) & Divisão \\
\hline
LT & (<, arg1, arg2, result) & Comparação menor que \\
\hline
LE & (<=, arg1, arg2, result) & Comparação menor ou igual \\
\hline
GT & (>, arg1, arg2, result) & Comparação maior que \\
\hline
GE & (>=, arg1, arg2, result) & Comparação maior ou igual \\
\hline
EQ & (==, arg1, arg2, result) & Comparação de igualdade \\
\hline
NE & (!=, arg1, arg2, result) & Comparação de desigualdade \\
\hline
GOTO & (goto, -, -, label) & Salto incondicional \\
\hline
IF\_GOTO & (if\_goto, cond, -, label) & Salto condicional \\
\hline
LABEL & (label, -, -, name) & Definição de rótulo \\
\hline
CALL & (call, func, nargs, result) & Chamada de função \\
\hline
RETURN & (return, -, -, value) & Retorno de função \\
\hline
PARAM & (param, -, -, arg) & Passagem de parâmetro \\
\hline
ALLOC & (alloc, -, size, var) & Alocação de array \\
\hline
LOAD & (load, array, index, result) & Carregamento de array \\
\hline
STORE & (store, value, array, index) & Armazenamento em array \\
\hline
INPUT\_OP & (input, -, -, result) & Operação de input \\
\hline
OUTPUT\_OP & (output, -, -, arg) & Operação de output \\
\hline
HALT & (halt, -, -, -) & Parada do programa \\
\hline
\end{tabular}
\end{table}

\subsection{Implementação da Geração de Código Intermediário}

A geração de código intermediário é realizada através de um percurso na AST:

\begin{lstlisting}[style=cstyle, caption=Estrutura das quádruplas]
typedef enum {
    ASSIGN, ADD, SUB, MULT, DIV, LT, LE, GT, GE, EQ, NE,
    GOTO, IF_GOTO, LABEL, CALL, RETURN, PARAM, ALLOC,
    LOAD, STORE, INPUT_OP, OUTPUT_OP, HALT
} OpKind;

typedef struct Operand {
    enum { VARIABLE, CONSTANT, TEMPORARY, LABEL_OP } kind;
    union {
        char *name;
        int val;
    };
} Operand;

typedef struct Quadruple {
    OpKind operation;
    Operand *oper1;
    Operand *oper2;
    Operand *oper3;
    int line;
} Quadruple;

static Quadruple *codeArray;
static int codeArraySize = 0;
static int codeArrayCapacity = 1000;
static int tempCounter = 0;
static int labelCounter = 0;
\end{lstlisting}

\subsection{Geração de Código para Expressões}

As expressões aritméticas são traduzidas para sequências de quádruplas:

\begin{lstlisting}[style=cstyle, caption=Geração de código para expressões]
Operand *generateExp(TreeNode *tree) {
    Operand *result = NULL;
    
    switch (tree->kind.exp) {
        case OpK:
            {
                Operand *left = generateExp(tree->child[0]);
                Operand *right = generateExp(tree->child[1]);
                result = newTemp();
                
                OpKind op;
                switch (tree->attr.op) {
                    case PLUS: op = ADD; break;
                    case MINUS: op = SUB; break;
                    case TIMES: op = MULT; break;
                    case OVER: op = DIV; break;
                    case LT: op = LT; break;
                    case LE: op = LE; break;
                    case GT: op = GT; break;
                    case GE: op = GE; break;
                    case EQ: op = EQ; break;
                    case NE: op = NE; break;
                }
                
                emitQuadrupla(op, left, right, result);
            }
            break;
            
        case ConstK:
            result = newOperand(CONSTANT);
            result->val = tree->attr.val;
            break;
            
        case IdK:
            result = newOperand(VARIABLE);
            result->name = strdup(tree->attr.name);
            break;
    }
    
    return result;
}
\end{lstlisting}

\section{Geração do Código Assembly}

A geração de código assembly traduz as quádruplas para instruções MIPS-64, implementando alocação de registradores e gerenciamento de memória.

\subsection{Implementação da Geração Assembly}

\begin{lstlisting}[style=assemblystyle, caption=Tradução de quádruplas para assembly]
void generateAssembly(Quadruple *quad) {
    switch (quad->operation) {
        case ADD:
            if (quad->oper1->kind == CONSTANT && quad->oper2->kind == CONSTANT) {
                emitAssembly("ori $t0 $zero %d", quad->oper1->val);
                emitAssembly("ori $t1 $zero %d", quad->oper2->val);
                emitAssembly("add $t2 $t0 $t1");
                storeResult("$t2", quad->oper3);
            } else {
                loadOperand(quad->oper1, "$t0");
                loadOperand(quad->oper2, "$t1");
                emitAssembly("add $t2 $t0 $t1");
                storeResult("$t2", quad->oper3);
            }
            break;
            
        case SUB:
            loadOperand(quad->oper1, "$t0");
            loadOperand(quad->oper2, "$t1");
            emitAssembly("sub $t2 $t0 $t1");
            storeResult("$t2", quad->oper3);
            break;
            
        case MULT:
            loadOperand(quad->oper1, "$t0");
            loadOperand(quad->oper2, "$t1");
            emitAssembly("mult $t2 $t0 $t1");
            storeResult("$t2", quad->oper3);
            break;
            
        case IF_GOTO:
            loadOperand(quad->oper1, "$t0");
            emitAssembly("beq $t0 $zero %s", quad->oper3->name);
            break;
            
        case CALL:
            emitAssembly("jal %s", quad->oper1->name);
            if (quad->oper3) {
                emitAssembly("add %s $temp $zero", getRegister(quad->oper3));
            }
            break;
    }
}
\end{lstlisting}

\section{Geração do Código Executável}

O código executável é gerado através da conversão das instruções assembly para código binário compatível com o processador MIPS-64.

\subsection{Codificação de Instruções}

\begin{lstlisting}[style=cstyle, caption=Codificação binária das instruções]
typedef struct InstrucaoBinaria {
    unsigned int opcode : 6;
    union {
        struct {  // Tipo R
            unsigned int rs : 5;
            unsigned int rt : 5;
            unsigned int rd : 5;
            unsigned int shamt : 5;
            unsigned int funct : 6;
        } r;
        struct {  // Tipo I
            unsigned int rs : 5;
            unsigned int rt : 5;
            unsigned int imediato : 16;
        } i;
        struct {  // Tipo J
            unsigned int endereco : 26;
        } j;
    };
} InstrucaoBinaria;

uint32_t codificarInstrucao(AssemblyInstr *instr) {
    InstrucaoBinaria bin = {0};
    
    switch (instr->tipo) {
        case TIPO_R:
            bin.opcode = 0;
            bin.r.rs = instr->rs;
            bin.r.rt = instr->rt;
            bin.r.rd = instr->rd;
            bin.r.shamt = instr->shamt;
            bin.r.funct = obterCodigoFunct(instr->mnemonic);
            break;
            
        case TIPO_I:
            bin.opcode = obterCodigoOpcode(instr->mnemonic);
            bin.i.rs = instr->rs;
            bin.i.rt = instr->rt;
            bin.i.imediato = instr->imediato;
            break;
            
        case TIPO_J:
            bin.opcode = obterCodigoOpcode(instr->mnemonic);
            bin.j.endereco = instr->endereco;
            break;
    }
    
    return *(uint32_t*)&bin;
}
\end{lstlisting>

\section{Gerenciamento de Memória}

O compilador implementa um sistema de gerenciamento de memória que organiza o espaço de endereçamento do programa.

\subsection{Layout de Memória}

O layout de memória é organizado da seguinte forma:

\begin{figure}[H]
\centering
\caption{Layout de memória do programa}
\label{fig:layout-memoria}
\begin{tabular}{|c|c|c|}
\hline
\textbf{Região} & \textbf{Endereço} & \textbf{Conteúdo} \\
\hline
Código & 0x0000 - 0x03FF & Instruções do programa \\
\hline
Dados Globais & 0x0400 - 0x04FF & Variáveis globais \\
\hline
Pilha & 0x0500 - 0x05FF & Pilha de execução \\
\hline
Heap & 0x0600 - 0x06FF & Arrays dinâmicos \\
\hline
\end{tabular}
\\
\textit{Fonte: O Autor}
\end{figure}

\subsection{Gerenciamento de Variáveis}

\begin{lstlisting}[style=cstyle, caption=Alocação de variáveis]
typedef struct VariableInfo {
    char *name;
    int offset;
    int size;
    int isArray;
    int isGlobal;
} VariableInfo;

static VariableInfo *varTable;
static int globalOffset = 0x0400;
static int localOffset = 0;

void allocateVariable(char *name, int size, int isArray, int isGlobal) {
    VariableInfo *var = &varTable[varCount++];
    var->name = strdup(name);
    var->size = size;
    var->isArray = isArray;
    var->isGlobal = isGlobal;
    
    if (isGlobal) {
        var->offset = globalOffset;
        globalOffset += size;
    } else {
        var->offset = localOffset;
        localOffset += size;
    }
}
\end{lstlisting}

\subsection{Gerenciamento de Pilha}

O compilador implementa um sistema de pilha para suporte a chamadas de função:

\begin{lstlisting}[style=assemblystyle, caption=Convenção de chamada de função]
# Prólogo da função
funcao:
    # Salvar registrador de retorno
    sw $ra 0($sp)
    subi $sp $sp 1
    
    # Salvar frame pointer
    sw $fp 0($sp)
    subi $sp $sp 1
    
    # Configurar novo frame
    add $fp $sp $zero
    subi $sp $sp <tamanho_frame>
    
    # ... corpo da função ...
    
    # Epílogo da função
    add $sp $fp $zero
    addi $sp $sp 1
    lw $fp 0($sp)
    addi $sp $sp 1
    lw $ra 0($sp)
    jr $ra
\end{lstlisting}

% --------------- Exemplos ---------------
\chapter{Exemplos}

Este capítulo apresenta três exemplos práticos de utilização do compilador, demonstrando a evolução do código desde a linguagem C- até o código executável final. Cada exemplo ilustra diferentes aspectos da linguagem e do processo de compilação.

\section{Exemplo 1: Operações Aritméticas Básicas}

Este primeiro exemplo demonstra operações aritméticas simples e o uso de variáveis.

\subsection{Código Fonte}

\begin{lstlisting}[style=cstyle, caption=Exemplo 1: Código fonte C-]
/* Programa: Operações aritméticas básicas */
void main(void) {
    int a;
    int b;
    int soma;
    int produto;
    
    a = 10;
    b = 5;
    soma = a + b;
    produto = a * b;
    
    output(soma);
    output(produto);
}
\end{lstlisting}

\subsection{Código Intermediário}

A geração de código intermediário produz as seguintes quádruplas:

\begin{lstlisting}[style=cstyle, caption=Exemplo 1: Código intermediário (quádruplas)]
0:  (alloc, -, 1, a)
1:  (alloc, -, 1, b)  
2:  (alloc, -, 1, soma)
3:  (alloc, -, 1, produto)
4:  (=, 10, -, a)
5:  (=, 5, -, b)
6:  (+, a, b, t1)
7:  (=, t1, -, soma)
8:  (*, a, b, t2)
9:  (=, t2, -, produto)
10: (output, -, -, soma)
11: (output, -, -, produto)
12: (halt, -, -, -)
\end{lstlisting}

\subsection{Código Assembly}

O código assembly gerado para o processador MIPS-64:

\begin{lstlisting}[style=assemblystyle, caption=Exemplo 1: Código assembly MIPS]
0:      j main                  # Pular para função main
1:  main:
2:      ori $fp $zero 0         # Inicializar frame pointer
3:      add $fp $fp $s0         # Ajustar base do frame
4:      ori $sp $zero 4         # Inicializar stack pointer
5:      add $sp $sp $s0         # Ajustar pilha
6:      ori $t0 $zero 10        # a = 10
7:      sw $t0 0($fp)           # Armazenar a
8:      ori $t1 $zero 5         # b = 5
9:      sw $t1 4($fp)           # Armazenar b
10:     lw $t2 0($fp)           # Carregar a
11:     lw $t3 4($fp)           # Carregar b
12:     add $t4 $t2 $t3         # soma = a + b
13:     sw $t4 8($fp)           # Armazenar soma
14:     lw $t5 0($fp)           # Carregar a
15:     lw $t6 4($fp)           # Carregar b
16:     mult $t7 $t5 $t6        # produto = a * b
17:     sw $t7 12($fp)          # Armazenar produto
18:     lw $t8 8($fp)           # Carregar soma para output
19:     out $zero $t8 0         # output(soma)
20:     lw $t9 12($fp)          # Carregar produto para output
21:     out $zero $t9 0         # output(produto)
22:     halt $zero              # Parar programa
\end{lstlisting}

\subsection{Código Executável}

O código binário gerado (primeiras instruções):

\begin{table}[H]
\centering
\caption{Exemplo 1: Código executável (binário)}
\begin{tabular}{|c|l|}
\hline
\textbf{Endereço} & \textbf{Instrução Binária (32 bits)} \\
\hline
0x0000 & 00001000000000000000000000000001 \\
\hline
0x0004 & 00110111111111110000000000000000 \\
\hline
0x0008 & 00000011111100001111000000100000 \\
\hline
0x000C & 00110111111110010000000000000100 \\
\hline
0x0010 & 00000011100101001110100000100000 \\
\hline
0x0014 & 00110100000010000000000000001010 \\
\hline
0x0018 & 10101111110010000000000000000000 \\
\hline
0x001C & 00110100000010010000000000000101 \\
\hline
0x0020 & 10101111110010010000000000000100 \\
\hline
\end{tabular}
\end{table}

\subsection{Correspondências}

\textbf{Código Fonte -> Código Intermediário}:
- A declaração \texttt{int a;} gera a quádrupla \texttt{(alloc, -, 1, a)}
- A atribuição \texttt{a = 10;} gera \texttt{(=, 10, -, a)}
- A expressão \texttt{a + b} gera \texttt{(+, a, b, t1)} seguida de \texttt{(=, t1, -, soma)}

\textbf{Código Intermediário -> Código Assembly}:
- A quádrupla \texttt{(=, 10, -, a)} gera \texttt{ori \$t0 \$zero 10} e \texttt{sw \$t0 0(\$fp)}
- A quádrupla \texttt{(+, a, b, t1)} gera \texttt{lw \$t2 0(\$fp)}, \texttt{lw \$t3 4(\$fp)} e \texttt{add \$t4 \$t2 \$t3}

\section{Exemplo 2: Algoritmo do MDC (Máximo Divisor Comum)}

Este exemplo demonstra o uso de recursão e estruturas de controle com um programa real testado no compilador.

\subsection{Código Fonte}

\begin{lstlisting}[style=cstyle, caption=Exemplo 2: Código fonte C- (gcd.cm)]
/* Um programa para calcular o mdc
   segundo o algoritmo de Euclides. */

int gcd (int u, int v)
{       
    if (v == 0) return u ;
    else return gcd(v,u-u/v*v);
    /* u-u/v*v == u mod v */
}

void main(void)
{   int x; int y;
    x = input(); y = input();
    output(gcd(x,y));
}
\end{lstlisting}

\subsection{Código Intermediário}

A geração de código intermediário produz as seguintes quádruplas (trecho):

\begin{lstlisting}[style=cstyle, caption=Exemplo 2: Código intermediário (quádruplas)]
(FUN, INT, gcd, 2)
(ARG, INT, u, gcd)
(ARG, INT, v, gcd)
(LOAD, $t0, u, -)
(LOAD, $t1, v, -)
(LOADI, $t2, 0, -)
(EQ, $t1, $t2, $t3)
(IF_FALSE, $t3, -, L1)
(LOAD, $t4, u, -)
(RETURN, $t4, -, -)
(GOTO, -, -, L2)
L1:
(LOAD, $t5, v, -)
(PARAM, $t5, -, -)
(LOAD, $t6, u, -)
(LOAD, $t7, u, -)
(LOAD, $t8, v, -)
(DIV, $t7, $t8, $t9)
(LOAD, $t10, v, -)
(MULT, $t9, $t10, $t11)
(SUB, $t6, $t11, $t12)
(PARAM, $t12, -, -)
(CALL, gcd, 2, $t13)
(RETURN, $t13, -, -)
L2:
(FUN, VOID, main, 0)
(ALLOC, x, main, -)
(ALLOC, y, main, -)
(INPUT, $t14, -, -)
(ASSIGN, x, $t14, -)
(INPUT, $t15, -, -)
(ASSIGN, y, $t15, -)
(LOAD, $t16, x, -)
(PARAM, $t16, -, -)
(LOAD, $t17, y, -)
(PARAM, $t17, -, -)
(CALL, gcd, 2, $t18)
(OUTPUT, $t18, -, -)
(HALT, -, -, -)
\end{lstlisting}

\subsection{Código Assembly}

O código assembly gerado para o processador MIPS (trecho da função gcd):

\begin{lstlisting}[style=assemblystyle, caption=Exemplo 2: Código assembly MIPS]
0:      j main
1:  gcd:
2:      sw $ra 0($sp)           # Salvar endereço de retorno
3:      subi $sp $sp 1          # Ajustar pilha
4:      sw $fp 0($sp)           # Salvar frame pointer
5:      subi $sp $sp 1
6:      add $fp $sp $zero       # Novo frame pointer
7:      subi $sp $sp 25         # Espaço para variáveis locais
8:      lw $t0 1($fp)           # Carregar parâmetro u
9:      lw $t1 2($fp)           # Carregar parâmetro v
10:     ori $t2 $zero 0         # Constante 0
11:     slt $t3 $t1 $t2         # v < 0
12:     slt $t4 $t2 $t1         # 0 < v
13:     xori $t5 $t3 1          # !(v < 0) = (v >= 0)
14:     xori $t6 $t4 1          # !(0 < v) = (0 >= v)
15:     and $t7 $t5 $t6         # (v >= 0) AND (0 >= v) = (v == 0)
16:     beq $t7 $zero L1        # Se v != 0, ir para L1
17:     lw $t8 1($fp)           # Carregar u para retorno
18:     add $temp $zero $t8     # Resultado em $temp
19:     j L2                    # Pular para fim
20: L1:
21:     lw $t9 2($fp)           # Carregar v
22:     sw $t9 0($sp)           # Parâmetro 1 para gcd recursivo
23:     subi $sp $sp 1
24:     lw $t10 1($fp)          # Carregar u
25:     lw $t11 1($fp)          # Carregar u
26:     lw $t12 2($fp)          # Carregar v
27:     div $t13 $t11 $t12      # u / v
28:     lw $t14 2($fp)          # Carregar v
29:     mult $t15 $t13 $t14     # (u/v) * v
30:     sub $t16 $t10 $t15      # u - (u/v)*v = u mod v
31:     sw $t16 0($sp)          # Parâmetro 2 para gcd recursivo
32:     subi $sp $sp 1
33:     jal gcd                 # Chamada recursiva
34:     addi $sp $sp 25         # Restaurar pilha após chamada
35:     # $temp já contém resultado da recursão
36: L2:
37:     addi $sp $sp 25         # Liberar espaço local
38:     addi $sp $sp 1
39:     lw $fp 0($sp)           # Restaurar frame pointer
40:     addi $sp $sp 1
41:     lw $ra 0($sp)           # Restaurar endereço de retorno
42:     jr $ra                  # Retornar
43: main:
44:     ori $fp $zero 0
45:     add $fp $fp $s0
46:     ori $sp $zero 26        # Inicialização do Stack Pointer
47:     add $sp $sp $s0
48:     in $zero $t17 0         # x = input()
49:     sw $t17 0($fp)
50:     in $zero $t18 0         # y = input()
51:     sw $t18 1($fp)
52:     lw $t19 0($fp)          # Carregar x
53:     sw $t19 0($sp)          # Parâmetro 1 para gcd
54:     subi $sp $sp 1
55:     lw $t20 1($fp)          # Carregar y
56:     sw $t20 0($sp)          # Parâmetro 2 para gcd
57:     subi $sp $sp 1
58:     jal gcd                 # Chamar gcd(x,y)
59:     addi $sp $sp 25         # Restaurar pilha
60:     out $zero $temp 0       # output(resultado)
61:     halt $zero
\end{lstlisting}

\subsection{Código Executável}

\begin{table}[H]
\centering
\caption{Exemplo 2: Código executável (trecho)}
\begin{tabular}{|c|l|}
\hline
\textbf{Endereço} & \textbf{Instrução Binária} \\
\hline
0x0000 & 00001000000000000000000000101011 \\
\hline
0x0004 & 10101111101111110000000000000000 \\
\hline
0x0008 & 00100011101111011111111111111111 \\
\hline
0x000C & 10101111101111100000000000000000 \\
\hline
0x0010 & 00100011101111011111111111111111 \\
\hline
0x0014 & 00000011101000001111000000100000 \\
\hline
0x0018 & 00100011101111011110011111101001 \\
\hline
0x001C & 10001111110010000000000000000001 \\
\hline
0x0020 & 10001111110010010000000000000010 \\
\hline
\end{tabular}
\end{table}

\subsection{Análise de Correspondências}

\textbf{Código Fonte → Código Intermediário:}
- A condição \texttt{if (v == 0)} gera as quádruplas de comparação e salto condicional
- A expressão \texttt{u-u/v*v} é decomposta em operações básicas (DIV, MULT, SUB)  
- A chamada recursiva \texttt{gcd(v,u-u/v*v)} gera PARAM e CALL

\textbf{Código Intermediário → Assembly:}
- A comparação EQ é implementada com duas instruções slt e operação xori
- O gerenciamento de pilha segue convenção MIPS com save/restore de \$ra e \$fp
- O cálculo do Stack Pointer reflete o uso dinâmico de memória para variáveis globais

\textbf{Destaque - Implementação do Módulo:}
A expressão C- \texttt{u-u/v*v} (equivalente a \texttt{u \% v}) é implementada através da sequência:
\begin{enumerate}
    \item \texttt{div \$t13 \$t11 \$t12} (divisão inteira)
    \item \texttt{mult \$t15 \$t13 \$t14} (multiplicação do quociente)
    \item \texttt{sub \$t16 \$t10 \$t15} (subtração para obter resto)
\end{enumerate}

\section{Exemplo 3: Manipulação de Arrays com Entrada Interativa}

Este exemplo demonstra o uso de arrays e funções de entrada e saída.

\subsection{Código Fonte}

\begin{lstlisting}[style=cstyle, caption=Exemplo 3: Código fonte C-]
/* Programa: Soma de elementos de um array */
void main(void) {
    int arr[5];
    int i;
    int soma;
    
    i = 0;
    soma = 0;
    
    /* Ler elementos do array */
    while (i < 5) {
        arr[i] = input();
        i = i + 1;
    }
    
    /* Calcular soma */
    i = 0;
    while (i < 5) {
        soma = soma + arr[i];
        i = i + 1;
    }
    
    output(soma);
}
\end{lstlisting}

\subsection{Código Intermediário}

\begin{lstlisting}[style=cstyle, caption=Exemplo 3: Código intermediário (quádruplas)]
0:  (alloc, -, 5, arr)
1:  (alloc, -, 1, i)
2:  (alloc, -, 1, soma)
3:  (=, 0, -, i)
4:  (=, 0, -, soma)
5:  L1: (<, i, 5, t1)
6:  (if_goto, t1, -, L2)
7:  (goto, -, -, L3)
8:  L2: (input, -, -, t2)
9:  (store, t2, arr, i)
10: (+, i, 1, t3)
11: (=, t3, -, i)
12: (goto, -, -, L1)
13: L3: (=, 0, -, i)
14: L4: (<, i, 5, t4)
15: (if_goto, t4, -, L5)
16: (goto, -, -, L6)
17: L5: (load, arr, i, t5)
18: (+, soma, t5, t6)
19: (=, t6, -, soma)
20: (+, i, 1, t7)
21: (=, t7, -, i)
22: (goto, -, -, L4)
23: L6: (output, -, -, soma)
24: (halt, -, -, -)
\end{lstlisting}

\subsection{Código Assembly}

% teste
% \lstinputlisting[
%     style=cstyle,  % Usando o mesmo estilo que você já definiu!
%     caption={Código-fonte C- do Exemplo 1.},
%     label={lst:exemplo1-fonte}
% ]{codes/src/main.c}


\begin{lstlisting}[style=assemblystyle, caption=Exemplo 3: Código assembly MIPS (trecho)]
0:      j main
1:  main:
2:      ori $fp $zero 0
3:      add $fp $fp $s0
4:      ori $sp $zero 7         # Espaço para array[5] + i + soma
5:      add $sp $sp $s0
6:      ori $t0 $zero 0         # i = 0
7:      sw $t0 20($fp)
8:      ori $t1 $zero 0         # soma = 0
9:      sw $t1 24($fp)
10: L1: lw $t2 20($fp)          # Carregar i
11:     ori $t3 $zero 5         # Constante 5
12:     slt $t4 $t2 $t3         # i < 5
13:     beq $t4 $zero L3        # Se falso, sair do loop
14: L2: in $zero $t5 0          # input()
15:     lw $t6 20($fp)          # Carregar i
16:     add $t7 $fp $t6         # Calcular endereco arr[i]
17:     sw $t5 0($t7)           # arr[i] = input()
18:     lw $t8 20($fp)          # Carregar i
19:     ori $t9 $zero 1         # Constante 1
20:     add $t10 $t8 $t9        # i + 1
21:     sw $t10 20($fp)         # i = i + 1
22:     j L1                    # Voltar ao início do loop
23: L3: ori $t11 $zero 0        # i = 0 (segundo loop)
24:     sw $t11 20($fp)
25: L4: lw $t12 20($fp)         # Carregar i
26:     ori $t13 $zero 5        # Constante 5
27:     slt $t14 $t12 $t13      # i < 5
28:     beq $t14 $zero L6       # Se falso, sair do loop
29: L5: lw $t15 24($fp)         # Carregar soma
30:     lw $t0 20($fp)          # Carregar i
31:     add $t1 $fp $t0         # Calcular endereço arr[i]
32:     lw $t2 0($t1)           # Carregar arr[i]
33:     add $t3 $t15 $t2        # soma + arr[i]
34:     sw $t3 24($fp)          # soma = soma + arr[i]
35:     lw $t4 20($fp)          # Carregar i
36:     ori $t5 $zero 1         # Constante 1
37:     add $t6 $t4 $t5         # i + 1
38:     sw $t6 20($fp)          # i = i + 1
39:     j L4                    # Voltar ao início do loop
40: L6: lw $t7 24($fp)          # Carregar soma
41:     out $zero $t7 0         # output(soma)
42:     halt $zero
\end{lstlisting}

\subsection{Código Executável}

\begin{table}[H]
\centering
\caption{Exemplo 3: Código executável (trecho)}
\begin{tabular}{|c|l|}
\hline
\textbf{Endereço} & \textbf{Instrução Binária} \\
\hline
0x0000 & 00001000000000000000000000100001 \\
\hline
0x0004 & 10101111101111110000000000000000 \\
\hline
0x0008 & 00100011101111011111111111111111 \\
\hline
0x000C & 10101111101111100000000000000000 \\
\hline
0x0010 & 00100011101111011111111111111111 \\
\hline
0x0014 & 00000011101000001111000000100000 \\
\hline
\end{tabular}
\end{table}

% --------------- Conclusão ---------------
\chapter{Conclusão}

O desenvolvimento do compilador C- para o processador MIPS-64 representou um projeto abrangente e desafiador que proporcionou um entendimento profundo dos princípios fundamentais de construção de compiladores. O projeto foi concluído com sucesso, atingindo todos os objetivos propostos e demonstrando a capacidade de gerar código executável correto e eficiente para a arquitetura alvo, que utiliza 32 registradores de 64 bits com convenções específicas de mapeamento.

\section{Dificuldades Encontradas Durante o Desenvolvimento}

Durante o desenvolvimento do compilador, várias dificuldades técnicas foram enfrentadas e superadas:

\subsection{Análise Sintática e Conflitos de Gramática}

Um dos principais desafios foi a resolução de conflitos na gramática da linguagem C-, especialmente o problema clássico de \textit{dangling else}. A solução implementada utilizou precedência de operadores no Bison, definindo que o \texttt{else} deve ser associado ao \texttt{if} mais próximo:

\begin{lstlisting}[style=cstyle]
%nonassoc LOWER_THAN_ELSE
%nonassoc ELSE
\end{lstlisting}

\subsection{Gerenciamento de Escopo e Tabela de Símbolos}

A implementação de múltiplos escopos (global, função, bloco) apresentou complexidade significativa. Foi necessário desenvolver uma pilha de escopos para gerenciar corretamente a visibilidade de variáveis e detectar erros de declaração dupla ou uso de variáveis não declaradas.

\subsection{Geração de Código para Recursão}

O suporte à recursão exigiu uma implementação cuidadosa do gerenciamento de pilha. O maior desafio foi garantir que os registradores e o frame pointer fossem salvos e restaurados corretamente a cada chamada de função, evitando corrupção de dados.

\subsection{Alocação de Registradores}

Embora tenha sido implementada uma estratégia simples de alocação de registradores usando registradores temporários, a otimização do uso de registradores se mostrou complexa. O compilador utiliza uma abordagem conservadora, recarregando valores da memória quando necessário.

\subsection{Implementação do Gerenciamento de Memória}

A implementação do sistema de gerenciamento de memória apresentou diversos desafios técnicos interessantes:

\begin{itemize}
    \item \textbf{Cálculo Dinâmico do Stack Pointer}: Implementação da lógica de inicialização dinâmica do ponteiro de pilha, garantindo inicialização correta baseada no uso de variáveis globais
    \item \textbf{Convenções de Chamada de Função}: Implementação precisa dos incrementos e decrementos de Frame Pointer e Stack Pointer (addi/subi \$fp/\$sp 25)
    \item \textbf{Gerenciamento de Registradores}: Implementação eficiente da convenção do projeto com 32 registradores e mapeamento otimizado, incluindo o uso do registrador \$zero (\$31)
    \item \textbf{Padrão de Comparação de Igualdade}: Implementação da sequência slt-slt-xori para operação EQ
\end{itemize}

\subsection{Otimização do Padrão de Atribuição}

A implementação seguiu rigorosamente o padrão LOAD → operação → ASSIGN → STORE, eliminando instruções STORE duplicadas e garantindo eficiência na geração de código assembly.

\section{Destaques do Projeto}

O projeto apresenta várias características notáveis que demonstram sua qualidade e completude:

\subsection{Arquitetura Modular}

O compilador foi desenvolvido seguindo uma arquitetura modular clara, com separação bem definida entre as fases de análise léxica, sintática, semântica e geração de código. Esta modularidade facilita manutenção, depuração e extensões futuras.

\subsection{Tratamento Robusto de Erros}

Foi implementado um sistema abrangente de detecção e reportagem de erros, incluindo:
- Erros léxicos (caracteres inválidos)
- Erros sintáticos (violações da gramática)
- Erros semânticos (tipos incompatíveis, variáveis não declaradas)
- Localização precisa dos erros com número da linha

\subsection{Suporte Completo à Linguagem C-}

O compilador suporta todas as características da linguagem C-, incluindo:
- Declarações de variáveis e arrays
- Estruturas de controle (if-else, while)
- Funções com parâmetros e recursão
- Operações aritméticas e relacionais
- Funções de entrada e saída

\subsection{Geração de Código Eficiente}

O código assembly gerado é funcionalmente correto e apresenta boa eficiência:
- Uso adequado de registradores MIPS
- Implementação correta de convenções de chamada
- Gerenciamento apropriado de pilha
- Código binário compatível com a especificação MIPS-64

\subsection{Bateria de Testes Abrangente}

Foi desenvolvida uma bateria de 25 testes que cobrem sistematicamente todas as funcionalidades da linguagem, desde programas simples até algoritmos complexos com recursão e manipulação de arrays.

\section{Contribuições Técnicas}

O projeto contribuiu com várias implementações técnicas significativas:

\begin{itemize}
    \item \textbf{Representação Intermediária}: Sistema de quádruplas bem estruturado que facilita a geração de código assembly
    \item \textbf{Gerenciamento de Memória}: Layout de memória organizado com suporte a variáveis globais, pilha e heap
    \item \textbf{Sistema de Tipos}: Verificação de tipos robusta com detecção de incompatibilidades
    \item \textbf{Geração de Código}: Tradução eficiente de construções de alto nível para instruções MIPS
\end{itemize}

\section{Impacto Educacional}

Este projeto demonstra de forma prática todos os conceitos fundamentais estudados na disciplina de compiladores, proporcionando uma compreensão completa do processo de tradução de linguagens. A implementação hands-on de cada fase do compilador consolida o conhecimento teórico e prepara para desafios mais avançados em sistemas de software.

\section{Limitações e Trabalhos Futuros}

Embora o compilador atenda completamente aos requisitos da linguagem C-, algumas limitações podem ser endereçadas em trabalhos futuros:

\begin{enumerate}
    \item \textbf{Otimizações}: Implementação de otimizações como eliminação de código morto, propagação de constantes e otimização de loops
    \item \textbf{Alocação de Registradores}: Algoritmos mais sofisticados de alocação para melhor utilização dos registradores disponíveis
    \item \textbf{Extensões da Linguagem}: Suporte a estruturas, ponteiros e bibliotecas externas
    \item \textbf{Depuração}: Geração de informações de debug para facilitar a depuração de programas compilados
    \item \textbf{Interface Gráfica}: Desenvolvimento de uma interface gráfica para o compilador
\end{enumerate}

\section{Considerações Finais}

O desenvolvimento deste compilador representou uma experiência educacional extremamente rica, proporcionando compreensão profunda dos princípios de construção de linguagens de programação e sistemas de compilação. O projeto demonstra que é possível construir um compilador completo e funcional seguindo metodologias rigorosas de engenharia de software.

O sucesso deste projeto valida a eficácia da abordagem pedagógica utilizada na disciplina, onde teoria e prática se complementam para formar um entendimento sólido dos conceitos fundamentais. O compilador desenvolvido serve não apenas como prova de conceito, mas como base para estudos e desenvolvimentos futuros na área de linguagens de programação e compiladores.

% ------------------------------------------------
% ELEMENTOS PÓS-TEXTUAIS
% ------------------------------------------------

% --------------- Referências ---------------
\begin{thebibliography}{9}

\bibitem{Aho2007}
AHO, Alfred V.; SETHI, Ravi; ULLMAN, Jeffrey D.
\textbf{Compilers: Principles, Techniques, and Tools}.
2. ed. Boston: Addison-Wesley, 2007.

\bibitem{Sipser2012}
SIPSER, Michael.
\textbf{Introduction to the Theory of Computation}.
3. ed. Boston: Cengage Learning, 2012.

\bibitem{Patterson2013}
PATTERSON, David A.; HENNESSY, John L.
\textbf{Computer Organization and Design: The Hardware/Software Interface}.
5. ed. Waltham: Morgan Kaufmann, 2013.

\bibitem{Appel2002}
APPEL, Andrew W.
\textbf{Modern Compiler Implementation in C}.
Cambridge: Cambridge University Press, 2002.

\bibitem{Louden2012}
LOUDEN, Kenneth C.; LAMBERT, Kenneth A.
\textbf{Programming Languages: Principles and Practices}.
3. ed. Boston: Cengage Learning, 2012.

\bibitem{Cooper2011}
COOPER, Keith D.; TORCZON, Linda.
\textbf{Engineering a Compiler}.
2. ed. Burlington: Morgan Kaufmann, 2011.

\bibitem{Grune2012}
GRUNE, Dick; VAN REEUWIJK, Kees; BAL, Henri E.; JACOBS, Ceriel J.H.; LANGENDOEN, Koen.
\textbf{Modern Compiler Design}.
2. ed. New York: Springer, 2012.

\bibitem{Muchnick1997}
MUCHNICK, Steven S.
\textbf{Advanced Compiler Design and Implementation}.
San Francisco: Morgan Kaufmann, 1997.

\end{thebibliography}

% ------------------------------------------------
% FIM DO DOCUMENTO
% ------------------------------------------------
\end{document}